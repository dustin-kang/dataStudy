# Vector and Matrix
## 행렬(Matrix)
> 행렬(matrix)는 **행 벡터를 원소로 가지는 2차원 배열**입니다.

$$ X = (x_{ij}) $$

<img width="826" alt="스크린샷 2023-01-11 오후 12 30 21" src="https://user-images.githubusercontent.com/55238671/211718382-0960bc56-4683-40c9-8e3d-2f5a83c9d1f7.png">

```py
x = np.array([[1, -2, 3],
            [7, 5, 0],
            [-2, -1, 2]])

# 2차원 배열이기 때문에 대괄호를 2번 묶습니다.
```

- 행렬 행(row)와 열(column)이라는 인덱스(index)를 가집니다.

> **전치 행렬(Transpose Matrix)**
> $$ X^T = (x_{ji})$$
> - 행과 열의 인덱스가 바뀐 행렬을 말합니다.

## 행렬을 이해하는 방법 1
- 벡터가 공간에서 한 점을 의미한다면, 행렬은 **여러 점**을 나타냅니다.
- 행렬의 **$x_{ij}$** 는 **i번째 데이터의 j 번째 변수**를 의미합니다. (행벡터 $x_i$ 는  i번째 데이터)

<img width="826" alt="스크린샷 2023-01-11 오후 1 25 49" src="https://user-images.githubusercontent.com/55238671/211718455-dac93b0d-c8a5-4933-85a7-ccde4954c519.png">



### 행렬의 덧셈, 뺄셈, 성분곱, 스칼라곱
- 행렬끼리 **같은 모양을 가지면** 덧셈, 뺄셈도 계산할 수 있습니다.

### 행렬 곱셈 (Matrix Multiplication)
- **i 번째 행벡터와 j 번째 열벡터 사이의 내적**으로 행렬을 계산할 수 있습니다.

$$ XY = (\sum_k x_{ik}y_{kj}) $$

<img width="842" alt="스크린샷 2023-01-11 오후 1 26 53" src="https://user-images.githubusercontent.com/55238671/211718466-d71e0095-3644-40b2-92e2-c4d307e273fb.png">




```py
# x의 i번째 행벡터 (3x3)
x = np.array([[1, -2, 3], 
            [7, 5, 0],    
            [-2, -1, 2]])

# y의 j번째 열벡터 (3x2)
y = np.array([[0, 1],
            [1, -1],    
            [-2, 1]])

# [1 x 0, -2 x 1, 3 x -2]  = 0 + -2 + -6 = -8

x @ y
```

> 📌 numpy의 내적(`numpy.inner`)과 행렬의 내적은 다릅니다.  (numpy는 **두 행렬의 행벡터들을 계산**하는 것입니다.)

## 행렬을 이해하는 방법 2

<img width="393" alt="image" src="https://user-images.githubusercontent.com/55238671/211718520-9086c044-e0e6-4125-8d34-8b302f3a0328.png">


### 연산자로서의 이해
- 행렬은 **벡터 공간에서 사용되는 연산자(operater)** 로 이해한다.
- 행렬곱을 이용해서 벡터를 **다른 차원의 공간**으로 보낼 수 있습니다.
- 행렬곱을 통해 **패턴을 추출**할 수 있고 **데이터를 압축**할 수 있습니다.

$$ z_i = \sum_j a_{ij}x_j $$
> 📌 모든 선형변환(Linear Transform)은 행렬곱으로 계산할 수 있습니다.

### 역행렬(Inverse Matrix)
- 어떤 행렬을 거꾸로 되돌리는 행렬을 말합니다.
- 역행렬은 **행과 열 숫자가 같고** **행렬식(determinant)가 0이 아닌 경우**에만 계산할 수 있습니다.

$$ AA^{-1} = A^{-1}A = I(\text{항등행렬}) $$

```py
X = np.array([[1, -2, 3],
            [7, 5, 0],
            [-2, -1, 2]])

inv_X = np.linalg.inv(X) # 역행렬

X @ inv_X
```

> 🔍 만일 역행렬을 계산할 수 없다면 유사역행렬(psedo-inverse; Moore-Penrose, $A^+$)을 이용합니다.
> - 행과 열의 숫자가 달라도 역행렬과 유사한 형태를 계산합니다.
> - 연립방정식을 푸는데 해를 구할 수 있고 선형회귀식을 찾을 수 있습니다.
> - `numpy.linalg.pinv`로 구할 수 있습니다.
> - 행이 열보다 큰 경우 : $A^+ = (A^TA)^{-1}A^T (A^+A=I \text{가 성립한다.})$
> - 열이 행보다 큰 경우 : $A^+ = A^T(AA^T)^{-1} (AA^+=I \text{가 성립한다.})$

